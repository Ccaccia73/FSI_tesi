\chapter{Software Packages used in this work}
\label{cha:software}

This chapter illustrates the main software tools used in this work. First, the coupling library \textit{preCICE} is introduced in Section \ref{sec:precice}. Then, the multibody dynamics solver \textit{MBDyn} being connected to preCICE is shortly presented in Section \ref{sec:mbdyn}.


\section{preCICE}
\label{sec:precice}

The main information concerning preCICE is taken from the official documentation: that is \cite{gatzhammer2014efficient} and  \cite{bungartz2016precice}. The preCICE website is also a source of documentation\footnote{\href{http://www.precice.org}{www.precice.org}}.

The open-source\footnote{The code can be accessed via Github: \href{https://github.com/precice/precice}{github.com/precice/precice}} software library preCICE provides the components to connect traditional single-physics solvers and create a partitioned multi-physics simulation (e.g. fluid-structure interaction, conjugated heat transfer, solid-solid interaction, etc.).
It aims at coupling existing solvers in a partitioned black-box manner (see Section \ref{sec:coupling}):  only minimal information abut the solver is available and connection involves just interface nodes. 
In order to be flexible and easily implemented, the impact on the solvers should be as minimal as possible: for this reason, preCICE offers a high level ~\ac{API} (Section \ref{sec:pc-api}) different languages, such as C/C++, Fortran and Python.
The ability to switch among different solvers is advantageous as it provides a lot of flexibility in developing and testing new coupled components.

In a nutshell, preCICE simply affects the input and observes the output of the solvers (called \textit{participants}). The required data and control elements are accessed using an \textit{adapter}, i.e. a "glue code" that is attached to the corresponding solver and communicates the information with the library.

preCICE performs all the actions required to perform a coupled simulation: implements the coupling strategy and convergence criteria (Section \ref{sec:pc-coupling}), the communication
between the participants (Section \ref{sec:pc-comm}), the mapping of data between meshes (Section \ref{sec:pc-map}). preCICE is configured by means of an ~\ac{XML} file (Section \ref{sec:pc-config}).



\subsection{Implemented coupling strategies}
\label{sec:pc-coupling}

The \textit{partitione approach} (Section \ref{sec:coupling}) is obviously the coupling strategy adopted by preCICE. It allows both \textit{explicit} (Section \ref{subsec:explicit}) and \textit{implicit} coupling (Section \ref{subsec:implicit}). The possible variants are four:

\begin{itemize}
	\item \texttt{serial-explicit}: a serial, weakly coupled algorithm (Figure \ref{fig:serial-explicit}). The first solver uses the second solver solution at the last time step to compute its current solution. In contrast, the second solver needs the current first solution to compute its solution at the same time instance. The order of execution is user defined.
	\item \texttt{parallel-explicit}: both solvers advance in parallel (Figure \ref{fig:parallel-explicit}) and exchange data at the end of each time step, resulting in a less stable procedure. The bottleneck of this procedure is related to the most time consuming solver.
	\item \texttt{serial-implicit}: a serial strongly coupled algorithm (Figure \ref{fig:serial-implicit}). The user can define the order of execution, the coupling algorithm (basically all the algorithms described in Section \ref{sec:strong-coupling}) and its parameters in a section of the configuration file named \texttt{acceleration}.
	\item \texttt{parallel-implicit}: again both solvers execute in parallel (Figure \ref{fig:parallel-implicit}). An implicit scheme modifies the result of the fixed-point iteration on both data \cite{mehl2016parallel}. 
\end{itemize}



\subsection{Communication strategies}
\label{sec:pc-comm}

All the participants need to communicate with each other, in order to share coupling data.
Each solver might be executed in multiple processes or on different nodes of a cluster (\textit{intrafield parallelism}).
This form of parallelization requires efficient forms of communication between the solver in order to avoid that data transfer becomes a bottleneck during a simulation.

preCICE implements a fully parallel process-to-process communication approach \cite{Shukaev2015} using:

\begin{itemize}
	\item \textit{~\ac{MPI}}: available on 	most scientific computers, it may be necessary to adapt/change the MPI versions of the respective single-physics solvers or of preCICE.
	\item \textit{~\ac{TCP/IP}}: popular means of network communication and free of incompatibilities between versions.
\end{itemize}

As to performances, MPI is the best technique especially when a high numbers of nodes is present. Anyway, socket communication is quite as fast, such that
both techniques are very well-suited for larger-scale simulations \cite{gatzhammer2014efficient}.

In each solver, executed in parallel, one "master" process is defined to manage the progress of the simulation. No central node is required. The participating
processes use asynchronous point-to-point (M:N) communication. The channels are static and defined in the beginning of the simulation. This sets a limit in using preCICE with dynamically adaptive meshes or immersed boundaries.

\subsection{Data mapping}
\label{sec:pc-map}

Even if volume coupling is possible, preCICE is mainly designed to couple simulations that share a common surface boundary (namely \textit{conforming meshes}, in the terminology used in Section \ref{sec:conforming-mesh}). The meshes don't need to be node-to-node coincident, so it is necessary to map variables at the interface, preserving the geometry (i.e. no gaps or superpositions at the interface) and the mass and energy balances. 

The user defines which data are shared by each \textit{participant} (i.e. solver) and the way data is shared in the configuration section named \texttt{mapping}. As described in Section \ref{sec:data-mapping}, two kinds of mapping are available:

\begin{itemize}
	\item \texttt{consistent}: the value of a node at the one grid is the same as the value of the corresponding node (or nodes) at the other grid. In general the number of fluid nodes is at least the same or, more often, exceeds the nodes of the structure, so a single structural node is associated to several fluid nodes. The mapping of displacements is consistent: in the simplest case, all fluid nodes experience the same displacement of a single solid node, otherwise an interpolation is performed (see Figure \ref{fig:consistent}).
	\item \texttt{conservative}: in the same conditions as before, forces are mapped from multiple fluid nodes to a single solid node in an additive manner (see Figure \ref{fig:conservative}).
\end{itemize} 

Along with the mapping strategy, a method must be defined (see Section \ref{sec:data-mapping}): \texttt{nearest-neighbor}, \texttt{nearest-projection}, \texttt{rbf}. For the latest method, preCICE implements a wide variety of basis functions, with Gaussian and thin plate splines being the most widely used.

 

\subsection{Configuration}
\label{sec:pc-config}

In order to run a multi-physics simulation with preCICE, all the participating, \textit{adapted} solvers have to be started (the order is irrelevant).
Some configuration files are needed:

\begin{itemize}
	\item each adapter in general needs its own configuration file. It normally contains information about the boundaries (wet-surface) used for the coupling, names of exchanged data, mesh and the name of the common preCICE configuration file, plus other parameters, specific to the adapter. The one for the MBDyn adapter will be described in more detail in Chapter \ref{cha:adapter} and in Appendix \ref{app:mbd-config-file}.
	\item preCICE configuration file: This is an XML file and each participant points at it. It defines all the information relevant to the simulation:
	\begin{itemize}
		\item type and name of exchanged data and meshes over which those data are passed
		\item which solvers participate in the simulation, which data produce or consume, and how the mapping is performed
		\item how solvers communicate among each other
		\item coupling scheme and all the necessary information 
	\end{itemize}
	
	The structure of a preCICE configuration file is illustrated in Appendix \ref{app:pc-config-file}.
		
\end{itemize}


\subsection{Application Program Interface}
\label{sec:pc-api}

A solver, in order to be coupled to preCICE, must either provide a way to access its core functions (e.g. initialize, set input data, read output, advance...) from outside the code (via API, socket, etc...) or it has to be slightly modified in order to perform all the operations required by the preCICE library.

The result is an \textit{adapter}, which can be the modified and recompiled original solver, or a standalone piece of code that communicates with the original unmodified solver on one side and with the preCICE library on the other. The adapter groups together all the calls to the preCICE methods from its API (a list of the API calls, taken from the official documentation, can be found in Appendix \ref{sec:api-code}).

While preCICE is written in C++, there exist APIs also for other languages, so that the adapter can be written also in C, Fortran or Python.

A coupling consists of a configuration and an initialization phase, multiple coupling advancements and a finalization phase: the general structure of an adapter can be found in \ref{sec:adapter-code}.


\subsection{Official Adapters}
\label{sec:pc-adapters}


This work introduces an adapter to preCICE for MBDyn. It is based on previous MBDyn adapters and on the examples given on the preCICE website\footnote{\href{https://github.com/precice/precice/wiki/Adapter-Example}{github.com/precice/precice/wiki/Adapter-Example}}.
Official adapters are currently available for several free solvers, e.g. CalculiX, Code-Aster and SU2. Also some closed-source software packages are supported. A (maybe outdated) list od official adapters can be found in \cite{uekermann2017official}, while the current status of coupled codes can be found at the following link: \href{https://www.precice.org/codes/}{preCICE adapters}.


\section{MBDyn}
\label{sec:mbdyn}


MBDyn is the first and possibly the only free* general purpose Multibody Dynamics analysis software, released under GNU's GPL 2.1 (get a cached copy here).

It has been developed at the Dipartimento di Scienze e Tecnologie Aerospaziali (formerly Dipartimento di Ingegneria Aerospaziale) of the University "Politecnico di Milano", Italy.

Multibody system is the study of the dynamic behavior of interconnected rigid or flexible bodies, each of which may undergo large translational and rotational displacements.

MBDyn features the integrated multidisciplinary simulation of multibody, multiphysics systems, including nonlinear mechanics of rigid and flexible bodies (geometrically exact & composite-ready beam and shell finite elements, component mode synthesis elements, lumped elements) subjected to kinematic constraints, along with smart materials, electric networks, active control, hydraulic networks, and essential fixed-wing and rotorcraft aerodynamics.

Note: since the software became available through a public git repository (https://gitlab.polimi.it/Pub/mbdyn),

to be cited \cite{masarati2014efficient}


%MBDyn has been developed to serve as an analysis tool for rotorcraft research. It has been used in the past, and is currently used, in a number of research projects,
%
%1.1 Basic Syntax
%A brief summary of the basic syntax is presented first. The syntax of an input file for
%MBDyn is structured in terms of statements. A statement follows the syntax:
%<card> [ : <arglist> ] ;
%that is, a valid card name, depending on its nature, may be followed by a colon and
%by a list of (comma separated) arguments; it is always terminated by a semicolon.
%Statements are logically divided in blocks. Each block is opened by a begin statement
%and it is closed by an end statement:
%begin: <block> ;
%# block data
%end: <block> ;
%The valid blocks (and their sequence) is:
%• data
%• <problem>
%• control data
%• nodes
%• drivers (optional)
%• elements
%• parallel (only if the parallel solver is used and explicit directives are required)
%The data block at present contains the type of problem that is solved by the analysis. The most significant one is initial value.
%The <problem> block takes the name of the problem defined in the data block; it
%contains all the information required by the integration method to perform the desired
%simulation regardless of the nature of the problem.
%The control data block mostly contains information about the problem that is
%required to ensure that a consistent model will be generated.
%The nodes block contains all the nodes required by the simulation. They are
%separated from the rest of the data for historical reasons, because the nodes are defined
%as the entities that make degrees of freedom available to the simulation, so they must
%exist before any element is generated.
%The drivers block is optional. It may contain some special driver data.
%Finally, the elements block contains all the elements. They are defined as the
%entities that generate equations using the degrees of freedom provided by the nodes.
%A layout of a typical input file is:
%begin: data;
%# global simulation data
%problem: initial value;
%end: data;
%begin: initial value;
%# problem-dependent data
%end: initial value;
%begin: control data;
%# global model data
%end: control data;
%begin: nodes;
%# nodes
%end: nodes;
%begin: drivers;
%# drivers
%end: drivers;
%begin: elements;
%# elements
%end: elements;
%
%
%output
%
%If we copy the above written code to a file called, say, “rigidbody”, and invoke
%mbdyn -f rigidbody
%after a while we obtain the results of the simulation in a set of files called “rigidbody.<ext>”.
%In this case, the extensions will be:
%• out for miscellaneous output
%• mov for the kinematic output of the node
%• ine for the dynamic output of the node
%• frc for the output of the force
%The first file (out) will be ignored at present. The second file (mov) will contain Nnodes
%by Ntimesteps lines formatted as:
%• the node label
%• the three coordinates of the position of the node
%• the three Euler-like angles that define the orientation of the node (following the
%1, 2, 3 convention)
%• the three components of the velocity of the node
%• the three components of the angular velocity of the node
%all the above mentioned quantities are expressed in the global inertial frame
%
%
%MODAL. see chap 8 del tutorial
%
%The modal body represents a very versatile manner to introduce the modeling of the
%essential dynamics of very complex deformable components, with some restrictions,
%into the multibody modeling environment. In essence, the dynamics of a deformable
%component is described as a linear combination of a reduced set of shapes and the
%related generalized mass, damping and stiffness matrices, plus some terms that describe
%selected nonlinearities in the inertia forces. This linear change in configuration with
%respect to the reference condition is superimposed to the finite motion of a regular
%multibody node, that accounts for the rigid body motion of the deformable component.
%Modal bodies are classified as joints in MBDyn, although they bring together features of bodies (inertia forces) and of joints (connections between multibody nodes).
%The interface between a modal element and the multibody environment is defined
%by means of regular multibody nodes that are “clamped” to the corresponding FEM
%nodes; as a consequence, the modal element can naturally connect to any multibody
%entity that can be connected to regular multibody structural nodes. The interface nodes
%must be separately defined in the control data and in the nodes sections. Since
%they are rigidly attached to the modal element, static multibody structural nodes
%can be used, unless some inertia is to be added in the multibody domain; in that case, a
%dynamic multibody structural node must be used.
%This tutorial uses the two hand-made FEM data files illustrated in Appendix A of
%the input manual to perform some basic analysis with trivial static and dynamic modal
%models. More sophisticated modal models can be manually prepared, or generated
%by means of NASTRAN following the procedure detailed in Appendix A of the input
%manual, or even generated from any FEM analysis software by manipulating the output
%as illustrated in the same reference.
%
%
%
%2.10 Constitutive Law
%
%Chapter 3
%Data
%The data section is read directly by the driver program. It is included between the cards:
%begin : data ;
%# ...
%end : data ;
%3.1 Problem
%The only active card is the problem card.
%The syntax is
%<card> ::= problem : <problem_name> ;
%<problem_name> ::= { initial value | inverse dynamics } ;
%For long time the only supported problem type was the initial value problem. As a consequence, if
%no problem card is present, an initial value problem is assumed. An experimental inverse dynamics
%problem is supported as well
%initial value, the time integration of mechanical and multidisciplinary problems formulated as
%Differential-Algebraic Equations (DAE). It can be downgraded to the solution of static and kinematic problems, by selecting purely static or kinematic contributions to the governing equations,
%thus giving time the role of an ordinal parameter.
%
%
%
%Chapter 5
%Control Data
%This section is read by the manager of all the bulk simulation data, namely the nodes, the drivers and
%the elements. It is used to set some global parameters closely related to the behavior of these entities,
%to tailor the initial assembly of the joints in case of structural simulations, and to tell the data manager
%how many entities of every type it should expect from the following sections. Historically this is due to
%the fact that the data structure for nodes and elements is allocated at the beginning with fixed size. This
%is going to change, giving raise to a “free” and resizeable structure. But this practice is to be considered
%reliable since it allows a sort of double-check on the entities that are inserted.
%
%
%6.1 Structural Node
%Structural nodes can have 6 degrees of freedom (position and orientation), and thus describe the kinematics of rigid-body motion in space, or 3 degrees of freedom (position) and thus describe the kinematics
%of point mass motion in space.
%The former has been originally implemented in MBDyn; the latter has been added in MBDyn 1.5.0,
%mainly to support the implementation of membrane elements.
%The 6 dof structural node can be static, dynamic, modal or dummy.
%The 3 dof structural node can be static or dynamic.
%Elements that only require displacement can be connected to either type of nodes; when connected
%to a 6 degree of freedom node, they only make use of position/velocity and only contribute to force
%equilibrium equations.
%Elements that require both displacement and orientation can only be connected to 6 degree of freedom
%nodes
%
%8.3 Beam Elements
%The family of finite volume beam elements implemented in MBDyn allows to model slender deformable
%structural components with a high level of flexibility.
%The beam is defined by a reference line and by a manifold of orientations attached to the line. It is
%assumed that the direction 1 of the orientations lies along the reference line, but it is not strictly required
%to be tangent to it even in the reference configuration.
%The beam element is defined by its nodes; currently, 2 and 3 node beam elements are implemented.
%Each node of the beam is related to a structural node by an offset and an optional relative orientation,
%to provide topological flexibility.
%The beam element is modeled by means of an original Finite Volume approach [13], which computes
%the internal forces as functions of the straining of the reference line and orientation at selected points
%along the line itself, called evaluation points, which lie somewhere between two pairs of beam nodes.
%At each evaluation point, a 6D constitutive law must be defined, which defines the relationship
%between the strains, the curvatures of the beam and their time derivatives and the internal forces and
%moments at the evaluation points.
%The strains and curvatures and their time derivatives are obtained from the nodal positions and
%orientations by differentiating the interpolation functions.
%The 6D constitutive laws are defined as
%
%
%
%Fx
%Fy
%Fz
%Mx
%My
%Mz
%
%
%
%= f
%
%
%
%
%
%εx
%γy
%γz
%κx
%κy
%κz
%
%
%
%,
%
%
%
%ε˙x
%γ˙y
%γ˙ z
%κ˙ x
%κ˙ y
%κ˙ z
%
%
%
%
%
%where, if the convention of using x as beam axis is followed:
%• Fx is the axial force component;
%• Fy and Fz are the shear force components;
%• Mx is the torsional moment component;
%
%
%
%My and Mz are the bending moment components;
%• εx is the axial strain component;
%• γy and γz are the shear strain components;
%• κx is the torsional curvature component;
%• κy and κz are the bending curvature component;
%• f is an arbitrary function that defines the constitutive law.
%8.3.1 Beam Section Constitutive Law
%Typically, linear elastic or viscoelastic constitutive laws are used, although one may want to implement
%specific nonlinear elastic or elastic-plastic constitutive laws.
%Beam Section Characterization
%MBDyn allows the broadest generality in defining what a linear elastic constitutive law contains, since
%the entire 6 × 6 constitutive matrix can be input. This means that internal forces and moments can be
%arbitrarily related to generalized strains and curvatures. However, to make sense, a constitutive matrix
%at the section level, must satisfy some constraints, e.g. it is expected to be symmetric, although this is
%not strictly enforced by the code.
%However, most of the info about the extra-diagonal terms of the stiffness matrix are not usually
%available. One easy way to work this around is to resort to any so-called composite beam section
%characterization analysis available in the literature.
%For details, the reader is referred to [14] for a review of the topic, to [15] for an early work on the
%subject, and to [16] for a more recent review of the original formulation. The software that implements
%this type of analysis is called ANBA++. It is not free software, so far. Prospective users can contact
%the authors, through MBDyn developers
%
%
%8.3.2 Three-node beam element
%The three-node beam element is described in detail in [13]. Each of the three points the beam element
%connects is referred to a structural node but can have an arbitrary offset to allow high generality in
%locating the structural reference line of the beam. Figure 8.4 illustrates the geometry of the three-node
%beam element.
%The finite volume formulation presented in [13] is used. As a consequence, the internal forces and
%moments are evaluated at two points that are at about midpoint between nodes 1 and 2, and nodes 2
%and 3 (at ξ = −1/
%√
%3 ∼= −0.57735 and ξ = 1/
%√
%3 ∼= 0.57735 of a non-dimensional abscissa ξ running from
%ξ = −1 at node 1 to ξ = 1 at node 3).
%So the constitutive properties must be supplied in these points, as well as the orientation matrices RI
%and RII , that express the orientation of the reference system the constitutive properties are expressed
%in with respect to the global frame (the axial force is conventionally defined in direction 1). Any of
%the supported 6D constitutive laws can be supplied to define the constitutive properties of each beam
%section.
%The traditional input format is
%<elem_type> ::= beam3
%<normal_arglist> ::=
%<node_1_label> , (Vec3) <relative_offset_1> ,
%<node_2_label> , (Vec3) <relative_offset_2> ,
%<node_3_label> , (Vec3) <relative_offset_3> ,
%(OrientationMatrix) <orientation_matrix_section_I> ,
%(ConstitutiveLaw<6D>) <constitutive_law_section_I> ,
%{ same | (OrientationMatrix) <orientation_matrix_section_II> } ,
%{ same | (ConstitutiveLaw<6D>) <constitutive_law_section_II> }
%[ , <custom_output> ]
%The relative_offset_<i>, with i=1,2,3, are the vectors oi
%, with i=1,2,3, of Figure 8.4.
%The orientation matrices orientation_matrix_section_<j>, with j=I,II, are the section orientation
%matrices Rj , with j=I,II, of Figure 8.4.
%
%
%
%
%
%8.4 Body
%The body element describes a lumped rigid body when connected to a regular, 6 degree of freedom
%structural node, or a point mass when connected to a rotationless, 3 degree of freedom structural node.
%
%
%
%8.8 Force
%The force element is a general means to introduce a right-hand side to the equations, i.e. an explicit
%contribution to the equations. There is a basic distinction between abstract and structural forces: abstract forces apply to arbitrary equations, while structural forces (and couples) are specific to structural
%nodes and have a spatial characterization. Essentially, structural forces have three components that may
%187
%depend on arbitrary parameters (usually the simulated time), and a location in space. Structural couples
%have three parameter-dependent components. The syntax of the force element is:
%
%8.8.9 External forces
%External forces are elements that allow to communicate with an external software that computes forces
%based on information on the kinematics of the model.
%Different communication schemes are supported. By default, communication occurs via files. Currently supported communication schemes are
%
%
%8.8.10 External Structural
%This element allows to communicate with an external software that computes forces applied to a pool
%of nodes and may depend on the kinematics of those nodes. Communication occurs by means of the
%communicators illustrated earlier.
%
%8.8.11 External structural mapping
%This element allows to communicate with an external software that computes forces applied to a pool
%of nodes and may depend on the kinematics of those nodes through a linear mapping. Communication
%occurs by means of the communicators illustrated earlier.
%
%A set of num_points points is generated first, by computing the kinematics of the points originating from
%the rigid-body motion of the structural nodes node_label according to the specified offset. Multiple
%offset blocks can appear for each node_label.
%The echo keyword causes the positions of those points to be written in a file named echo_file_name.
%If the keyword stop is present, the simulation ends here. This is useful to generate the bulk data that is
%needed to compute the linear mapping matrix. The optional keyword precision allows to set precision
%digits in the logged data; the other optional keywords refer to values that are written verbatim to the
%file. In detail, surface_file_name is the name of the file that contains the coordinates of the peer’s
%points, output_file_name is the name of the file that will contain the mapping matrix, order is an
%integer (1 ≤ order ≤ 3), basenode is the number of nodes for each region (basenode > 0), weight is a
%weighting coefficient (weight ≥ −2 or inf)
%When the reference node keyword is present, the kinematics of the points is formulated in the reference frame of node ref_node_label. The forces are expected in the same reference frame. In this case,
%if use reference node forces is set to yes, the force and moment related to node ref_node_label
%
%
%returned by the external solver are used; if rotate reference node forces is set to yes, they are first
%rotated in the global reference frame.
%When the mapped points number keyword is present, a mapping matrix is read from the file named
%mapping_file_name (same as output_file_name when the echo keyword is used). If the keyword from
%file is used, the number of mapped_points is computed from the number of rows of the matrix in file
%mapping_file_name. The matrix must be (3 × mapped_points) × (3 × num_points). If the mapped
%points number keyword is not present, the element behaves as if the mapping were the identity matrix,
%namely the position and the velocity of the points rigidly offset from MBDyn’s nodes are directly passed
%to the peer solver. See the modal variant for a description of the mapping file format.
%The labels of the original points, indicated as point_label, and the labels of the mapped points,
%either contained in the mapped_labels_file_name, or directly listed as mapped_label, must be provided
%when labels is set to yes.
%Mapping. The mapping consists in a constant matrix that allows to compute the position and the
%velocity of the mapped points (subscript ‘peer’) as functions of a set of points rigidly offset from MBDyn’s
%nodes (subscript ‘mbdyn’),
%
%xpeer = Hxmbdyn (8.66a)
%x˙ peer = Hx˙ mbdyn (8.66b)
%The same matrix is used to map back the forces onto MBDyn’s nodes based on the preservation of the
%work done in the two domains,
%δx
%T
%mbdynfmbdyn = δx
%T
%peerfpeer = δx
%T
%mbdynHT fpeer (8.67)
%which implies
%fmbdyn = HT fpeer (8.68)
%To compute matrix H one needs to:
%
% gather the coordinates of the set of points used by the peer process (subscript ‘peer’ in the formulas
%above) in a file, formatted as
%<num_points>
%<x_1> <y_1> <z_1>
%...
%<x_n> <y_n> <z_n>
%If reference node is defined, the points need to be expressed in a reference frame coincident with
%that of node ref_node_label.
%2. execute MBDyn’s input file after uncommenting the echo line in the definition of the external structural mapping force element, terminated by the stop keyword, to generate the echo_file_name
%file with MBDyn’s points coordinates (subscript ‘mbdyn’ in the formulas above).
%3. start octave
%4. make sure the folder contrib/MLS/ is in octave’s path
%addpath(’/path/to/contrib/MLS’)
%5. execute the create_mls_interface function
%
%create_mls_interface(’echo_file_name’);
%This generates the mapping matrix H, using the files echo_file_name and surface_file_name
%(the latter is written in echo_file_name by the surface keyword). The matrix is stored in the
%file output_file_name. The sparse storage is recommended, since for usual problems the matrix
%is significantly sparse
%
%From this point on, when MBDyn is executed it loads the mapping matrix from file output_file_name
%using sparse storage, automatically ignoring coefficients whose absolute value is below threshold (defaults to 0).
%The parameters of the mapping, as documented in create_mls_interface, are
%
%[14] Dewey H. Hodges. Review of composite rotor blade modeling. AIAA Journal, 28(3):561–565, March
%1990.
%
%[15] Vittorio Giavotto, Marco Borri, Paolo Mantegazza, Gian Luca Ghiringhelli, V. Caramaschi, G. C.
%Maffioli, and F. Mussi. Anisotropic beam theory and applications. Computers & Structures, 16(1–
%4):403–413, 1983.
%[16] Pierangelo Masarati. On the semi-analytical solution of beams subjected to distributed loads. In
%XVI Congresso Nazionale AIDAA, pages 72.1–10, Palermo, 24–28 Settembre 2001.